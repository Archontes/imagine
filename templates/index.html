<html>
<head>
<link rel="icon" type="image/png" href="/static/favicon.png" />
<link rel="shortcut icon" href="/static/favicon.ico" />
<link rel="stylesheet" href="/static/leaflet-0.7.3.css" />
<script src="/static/leaflet-src.js"></script>
<script src="/static/jquery-2.1.1.min.js"></script>
<script src="/static/leaflet-pip-20150130.min.js"></script>

<style type="text/css">
#map { height: 100%; width: 100%; padding: 1;}

#thebody { margin:1; }

.info {
    padding: 6px 8px;
    font: 14px/16px Arial, Helvetica, sans-serif;
    background: white;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 5px;
}

.inbrickccd {
    padding: 6px 8px;
    font: 14px/16px Arial, Helvetica, sans-serif;
    background: white;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 5px;
}

.inbrickccd ul {
    margin-top: 0pt;
}

.highccd {
    color: red;
}
.highccd:link {
    color: red;
}
.highccd:visited {
    color: red;
}

</style>
</head>

<body id="thebody">
<div id="map" />

<script>
MyTileLayer = L.TileLayer.extend({
    _loadTile: function (tile, tilePoint) {
        // this is just copied from the superclass
        tile._layer  = this;
        tile.onload  = this._tileOnLoad;
        tile.onerror = this._tileOnError;
        this._adjustTilePoint(tilePoint);
        tile.src     = this.getTileUrl(tilePoint);
        // this is special sauce - add zoom,x,y to tile object
        tile.tilex = tilePoint.x;
        tile.tiley = tilePoint.y;
        tile.z = tilePoint.z;
        // copied
        this.fire('tileloadstart', {
            tile: tile,
            url: tile.src,
        });
    },
});

var subdomains = ['a','b','c','d'];

function getSubdomain(x,y) {
	return subdomains[Math.abs(x + y) % subdomains.length];
}

function catLoaded(result) {
    //console.log('catloaded:' + result);
    if (!showSources) {
        return;
    }
    //console.log('catloaded:' + result['rd']);
    rdlist = result['rd']
    if ((result['zoom'] == undefined) || 
        (result['tilex'] == undefined) || 
        (result['tiley'] == undefined)) {
        return;
    }
    var circleList = new Array(rdlist.length);
    for (i=0, len=rdlist.length; i<len; i++) {
        r = rdlist[i][0];
        d = rdlist[i][1];
        lat = d;
        lng = 180 - r;
        circleList[i] = L.circle([lat, lng], 10);
    }
    circles = L.layerGroup(circleList);
    sourcesGroup.addLayer(circles);
    // save this for later.
    key = ''+result['zoom']+':'+result['tilex']+':'+result['tiley'];
    catLayers[key] = circles;
}

function doLoadTile(tile) {
    if (tile.z < 12) {
        return;
    }
    s = getSubdomain(tile.tilex, tile.tiley);
    caturl = L.Util.template('{{ caturl|safe }}', L.extend({
        s: s,
        z: tile.z,
        x: tile.tilex,
        y: tile.tiley,
        id: idname,
        ver: getcatversion(idname),
    }));
    $.getJSON(caturl, catLoaded);
}

function onTileLoadStart(e) {
    tile = e.tile;
    key = '' + tile.z + ':' + tile.tilex + ':' + tile.tiley;
    visibleTiles[key] = tile;
    //console.log('onTileLoadStart: ' + key);
    if (!showSources) {
        return;
    }
    doLoadTile(tile);
}

function doUnloadTile(key) {
    //console.log('doUnloadTile: ' + key);
    circles = catLayers[key];
    //map.removeLayer(circles);
    sourcesGroup.removeLayer(circles);
    delete catLayers[key];
}

function onTileUnload(e) {
    tile = e.tile;
    key = ''+tile.z+':'+tile.tilex+':'+tile.tiley;
    //console.log('onTileUnload: ' + key);
    delete visibleTiles[key];
    if (!showSources) {
        return;
    }
    // console.log('TileUnload: ' + tile.toString());
    doUnloadTile(key);
}

function brick_detail(name) {
    return '<a href="{% url 'brick_detail_blank' %}' + name
        + '/">' + name + '</a>';
}

function ccd_detail(name, aparams) {
    return '<a href="{% url 'ccd_detail_blank' %}' + name
        + '/"' + aparams + '>' + name + '</a>';
}

function onMapClick(e) {
    ra = 180 - e.latlng.lng;
    dec = e.latlng.lat;
    bricks = bricksUnderLatlng(e.latlng);
    ccds = ccdsUnderLatlng(e.latlng);
    txt = 'RA,Dec = ' + ra.toFixed(4) + ', ' + dec.toFixed(4) +
        '<br/><a href="{{ baseurl }}ra=' + ra.toFixed(4) +
        '&dec=' + dec.toFixed(4) + '&zoom=' + map.getZoom()
        + '">link here</a>';
    if (bricks.length) {
        for (var i=0; i<bricks.length; i++) {
            txt += '<br/>Brick: ' + brick_detail(bricks[i]);
        }
    }
    if (ccds.length) {
        for (var i=0; i<ccds.length; i++) {
            txt += '<br/>CCD: ' + ccd_detail(ccds[i], '');
        }
    }
    popup.setLatLng(e.latlng).setContent(txt).openOn(map);
}

function onMouseMove(e) {
    ra = 180 - e.latlng.lng;
    dec = e.latlng.lat;
    info._div.innerHTML = 'RA,Dec = ' + ra.toFixed(4) + ", " + dec.toFixed(4);
    if (inbrickccdAdded) {
        //props = { ra:ra, dec:dec };
        e.ra = ra;
        e.dec = dec;
        inbrickccdUpdate(e);
    }
}

function bricksUnderLatlng(latlng) {
    // Returns a list of the brick names under a given lat,long
    bricks = [];
    if (showBricks) {
        geos = [];
        for (var name in currentBricks) {
            brick = currentBricks[name];
            gj = brick.toGeoJSON();
            gj.properties['name'] = name;
            geos.push(gj);
        }
        geo = {type:'FeatureCollection', features:geos};
        leafgeo = L.geoJson(geo);
        inside = leafletPip.pointInLayer(latlng, leafgeo);
        for (var i=0; i<inside.length; i++) {
            bricks.push(inside[i].feature.properties.name);
        }
        bricks.sort();
    }
    return bricks;
}

function ccdsUnderLatlng(latlng) {
    ccds = [];
    if (showCcds) {
        geos = [];
        for (var name in currentCcds) {
            ccd = currentCcds[name];
            gj = ccd.toGeoJSON();
            gj.properties['name'] = name;
            geos.push(gj);
        }
        geo = {type:'FeatureCollection', features:geos};
        leafgeo = L.geoJson(geo);
        inside = leafletPip.pointInLayer(latlng, leafgeo);
        for (var i=0; i<inside.length; i++) {
            ccds.push(inside[i].feature.properties.name);
        }
        if (highlightedCcdName != '') {
            if (ccds.indexOf(highlightedCcdName) == -1) {
                ccds.push(highlightedCcdName);
            }
        }
        ccds.sort();
    }
    return ccds;
}

function inbrickccdUpdate(props) {
    if (props == undefined) {
        return;
    }
    bricks = bricksUnderLatlng(props.latlng);
    ccds = ccdsUnderLatlng(props.latlng);
    txt = '';
    if (bricks.length || ccds.length) {
        if (bricks.length) {
            txt = txt + 'In brick: ';
            for (var i=0; i<bricks.length; i++) {
                if (i) {
                    txt = txt + ', ';
                }
                txt = txt + brick_detail(bricks[i]);
            }
            if (ccds.length) {
                txt = txt + '<br/>';
            }
        }
        if (ccds.length) {
            txt = txt + 'In CCDs:<ul>';
            for (var i=0; i<ccds.length; i++) {
                ccdname = ccds[i];
                aparams = '';
                if (ccdname == highlightedCcdName) {
                    aparams = ' class="highccd"';
                }
                //ccdtext = ccdname;
                ccdtext = ccd_detail(ccdname, aparams);
                //ccdtext = '<div class="highccd">' + ccdtext + '</div>';
                //}
                txt = txt + '<li>'+ccdtext+'</li>';
            }
            txt = txt + '</ul>';
        }
    }
    inbrickccd._div.innerHTML = txt;
}

// "Sources", "Bricks", "CCDs" button checked
function overlayAdded(e) {
    //console.log('OverlayAdded: ' + e.name);
    if (e.name == 'Sources') {
        showSources = true;
        // request catalogs for currently-visible tiles
        //console.log('Visible tiles: ' + visibleTiles);
        for (var i in visibleTiles) {
            doLoadTile(visibleTiles[i]);
        }
    }
    if (e.name == 'Bricks') {
        showBricks = true;
        mapBoundsChanged();
    }
    if (e.name == 'CCDs') {
        showCcds = true;
        mapBoundsChanged();
    }
    if (showBricks || showCcds) {
        if (!inbrickccdAdded) {
            inbrickccd.addTo(map);
            inbrickccdAdded = true;
        }
    }
}

// "Sources", "Bricks", "CCDs" button unchecked
function overlayRemoved(e) {
    //console.log('OverlayRemoved: ' + e.name);
    if (e.name == 'Sources') {
        showSources = false;
        // remove all catalogs
        for (var i in visibleTiles) {
            doUnloadTile(i);
        }
    }
    if (e.name == 'Bricks') {
        showBricks = false;
        for (var i in currentBricks) {
            removeBrick(i);
        }
    }
    if (e.name == 'CCDs') {
        showCcds = false;
        for (var i in currentCcds) {
            removeCcd(i);
        }
        for (var name in ccdFills) {
            map.removeLayer(ccdFills[name]);
            delete ccdFills[name];
        }
    }
    if (!(showBricks || showCcds)) {
        if (inbrickccdAdded) {
            map.removeControl(inbrickccd);
            inbrickccdAdded = false;
        }
    }
}

function removeBrick(name) {
    brick = currentBricks[name];
    bricksGroup.removeLayer(brick);
    delete currentBricks[name];
}

function removeCcd(name) {
    ccd = currentCcds[name];
    ccdsGroup.removeLayer(ccd);
    delete currentCcds[name];
}

function bricksLoaded(result) {
    if (!showBricks) {
        return;
    }
    bricks = result['bricks'];
    for (var i=0, len=bricks.length; i<len; i++) {
        //console.log('brick ' + i + ': ' + bricks[i]);
        name = bricks[i].name;
        if (name in currentBricks) {
            //console.log('Brick ' + name + ' already exists');
            continue;
        }
        poly = bricks[i].poly;
        b = L.polygon(poly, {fill:false, weight:4, color:'blue' });
        b.name = name;
        //console.log('Adding brick ' + name + ': polygon ' + poly);
        bricksGroup.addLayer(b);
        currentBricks[name] = b;
    }
}

function unhighlightCcd(name) {
    map.removeLayer(ccdFills[name]);
    delete ccdFills[name];
}

function highlightCcd(ccd) {
    cf = L.polygon(ccd.getLatLngs(),
                   {fill:true, fillOpacity:0.05, color:'yellow', weight:1});
    ccdFills[ccd.name] = cf;
    cf.addTo(map);
    cf.bringToBack();
}

function ccdMouseOver(e) {
    e.target.setStyle({color: 'yellow'});
    ccd = e.target;
    highlightedCcdName = ccd.name;
    console.log('ccdMouseOver: ' + highlightedCcdName);
    // remove other CCDs from ccdFills
    for (var i=0; i<ccdFills.length; i++) {
        console.log('ccdMouseOver: ccd ' + ccd.name + '; ccdFills ' + ccdFills[i]);
        if (ccdFills[i] != ccd.name) {
            unhighlightCcd(ccdFills[i]);
        }
    }
    if (!(ccd.name in ccdFills)) {
        highlightCcd(ccd);
    }
    inbrickccdUpdate(e);
}

function ccdMouseOut(e) {
    e.target.setStyle({color: 'green'}); //, fill:false, fillOpacity:0});
    ccd = e.target;
    highlightedCcdName = '';
    if (ccd.name in ccdFills) {
        unhighlightCcd(ccd.name);
    }
    inbrickccdUpdate(e);
}

function ccdsLoaded(result) {
    if (!showCcds) {
        return;
    }
    ccds = result['ccds'];
    for (var i=0, len=ccds.length; i<len; i++) {
        // console.log('ccd ' + i + ': ' + ccds[i]);
        name = ccds[i].name;
        if (name in currentCcds) {
            //console.log('Ccd ' + name + ' already exists');
            continue;
        }
        poly = ccds[i].poly;
        c = L.polygon(poly, {fill:false, color:'green', weight:4 });
        c.name = name;
        c.on('mouseover', ccdMouseOver);
        c.on('mouseout', ccdMouseOut);
        // console.log('Adding ccd ' + name + ': polygon ' + poly);
        ccdsGroup.addLayer(c);
        currentCcds[name] = c;
    }
}

function mapBoundsChanged() {
    latlng = map.getCenter();
    zoom = map.getZoom();
    ra = 180 - latlng.lng;
    dec = latlng.lat;
    //console.log('map zoom: ' + zoom + ', RA,Dec ' + ra + ', ' + dec);
    if (showBricks) {
        bounds = map.getBounds();
        bricksurl = L.Util.template('{{ bricksurl|safe }}', L.extend({
            s: 'a',
            z: zoom,
            west: (180 - bounds.getWest()).toFixed(4),
            east: (180 - bounds.getEast()).toFixed(4),
            north: bounds.getNorth().toFixed(4),
            south: bounds.getSouth().toFixed(4),
            id: idname,
        }));
        $.getJSON(bricksurl, bricksLoaded);
    }
    if (showCcds) {
        bounds = map.getBounds();
        ccdsurl = L.Util.template('{{ ccdsurl|safe }}', L.extend({
            s: 'a',
            z: zoom,
            west: (180 - bounds.getWest()).toFixed(4),
            east: (180 - bounds.getEast()).toFixed(4),
            north: bounds.getNorth().toFixed(4),
            south: bounds.getSouth().toFixed(4),
            id: idname,
        }));
        $.getJSON(ccdsurl, ccdsLoaded);
    }
}

function onMapMoveEnd(e) {
    //console.log('Map move end.');
    mapBoundsChanged();
}

var inbrickccd = L.control();
inbrickccd.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'inbrickccd');
    this.update();
    return this._div;
};
inbrickccd.update = inbrickccdUpdate;
var inbrickccdAdded = false;

var showSources = false;
var sourcesGroup = L.layerGroup([]);
var catLayers = {};
var visibleTiles = {};

var showBricks = false;
var bricksGroup = L.layerGroup([]);
var currentBricks = {};

var showCcds = false;
var ccdsGroup = L.layerGroup([]);
//ccdsGroup.onAdd = function(map) {
//    console.log('ccdsGroup.onAdd');
//    overlayAdded({name:'CCDs'});
//}

var currentCcds = {};
var ccdFills = {};
var highlightedCcdName = '';

var map = L.map('map');
var popup = L.popup();

// default to 1.
var tileversions = {
    'decals-pr':4,
};
var catversions  = {};

function getversion(layer) {
    if (layer in tileversions) {
        return tileversions[layer];
    }
    return 1;
}

function getcatversion(layer) {
    if (layer in catversions) {
        return catversions[layer];
    }
    return 1;
}

var idname = '{{ layer }}';

tiles = new MyTileLayer('{{ tileurl|safe }}', {
    maxZoom: 18,
    attribution: '<a href="http://legacysurvey.org">DECaLS</a>',
    //id: 'decals',
    id: 'decals-pr',
    ver: getversion('decals-pr'),
    // ?
    unloadInvisibleTiles: true,
    subdomains: subdomains,
});
tiles.on('tileloadstart', onTileLoadStart);
tiles.on('tileunload',    onTileUnload);

tilesMod = new MyTileLayer('{{ tileurl|safe }}', {
    maxZoom: 18,
    attribution: '<a href="http://legacysurvey.org">DECaLS</a>',
    id: 'decals-model-pr',
    ver: getversion('decals-model-pr'),
    // ?
    unloadInvisibleTiles: true,
    subdomains: subdomains,
});
tilesMod.on('tileloadstart', onTileLoadStart);
tilesMod.on('tileunload',    onTileUnload);

var baseMaps = {
    "DECaLS images": tiles,
    "DECaLS models": tilesMod,
};

if (idname == 'decals') {
    tiles.addTo(map);
} else if (idname == 'decals-model') {
    tilesMod.addTo(map);
} else {

    xtiles = new MyTileLayer('{{ tileurl|safe }}', {
        maxZoom: 18,
        attribution: '<a href="http://legacysurvey.org">DECaLS</a>',
        id: idname,
        ver: getversion(idname),
        // ?
        unloadInvisibleTiles: true,
        subdomains: subdomains,
    });
    xtiles.on('tileloadstart', onTileLoadStart);
    xtiles.on('tileunload',    onTileUnload);
    baseMaps[idname] = xtiles;
    xtiles.addTo(map);
}

var info = L.control();
info.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'info');
    this._div.innerHTML = '{{ ra|floatformat:4}}, {{ dec|floatformat:4}}';
    return this._div;
};
info.addTo(map);

var overlayMaps = {
    "Sources": sourcesGroup,
    "Bricks": bricksGroup,
    "CCDs": ccdsGroup,
};

L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

map.on('mousemove', onMouseMove);
map.on('overlayadd', overlayAdded);
map.on('overlayremove', overlayRemoved);
map.on('click', onMapClick);
map.on('moveend', onMapMoveEnd);

map.setView([ {{ lat }}, {{ long }}], {{ zoom }});

{% if showBricks %}
map.addLayer(bricksGroup);
overlayAdded({name:'Bricks'});
{% endif %}

{% if showCcds %}
console.log('addLayer(ccds)');
map.addLayer(ccdsGroup);
console.log('done addLayer(ccds)');
overlayAdded({name:'CCDs'});
{% endif %}

</script>
</body>
</html>
